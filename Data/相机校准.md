# ç›¸æœºæ ¡å‡†

é¦–å…ˆæ˜¯å‡ å¼ éå¸¸é‡è¦çš„Slidesï¼Œåé¢éƒ½ä¼šreferåˆ°ï¼Œå¯ä»¥å…ˆè‡ªè¡Œç†Ÿæ‚‰ä¸‹ã€‚å¦å¤–ï¼Œæœ¬ç¯‡ä¸æ˜¯100%ä»é›¶å¼€å§‹çš„æ•™ç¨‹ï¼Œç¯‡å¹…é™åˆ¶å¹¶æ— æ³•å±•å¼€æ‰€æœ‰çš„ç»†èŠ‚ï¼Œè‹¥æƒ³æ·±åº¦ç†è§£ï¼Œè¯·è‡ªè¡Œç»“åˆå‡ ä¸ªå¤§å­¦ï¼ˆCMUï¼ŒStanfordï¼‰ç›¸åº”çš„Slidesä¸€èµ·å­¦ä¹ ã€‚



<img src="ç›¸æœºæ ¡å‡†/image-20221021152707045.png" alt="image-20221021152707045" style="zoom:33%;" />

![image-20221021165722788](ç›¸æœºæ ¡å‡†/image-20221021165722788.png)

## Coordinates

- åœ¨æ•´ä¸ªç›¸æœºçš„æŠ•å½±ä¸æ ¡å‡†è¿‡ç¨‹ä¸­ï¼Œä¸€å…±æ¶‰åŠ3ä¸ªåæ ‡ç³»ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯ï¼š
  1. ä¸–ç•Œåæ ‡ç³»ï¼šä»¥ç©ºé—´ä¸­æŸç‚¹ä¸ºåŸç‚¹å»ºç«‹æ¬§æ‹‰åæ ‡ç³»ï¼Œè®¾å®šxyzæ–¹å‘åå½¢æˆçš„åæ ‡ç³»ã€‚
  2. ç›¸æœºåæ ‡ç³»ã€‚è¯¥åæ ‡ç³»çš„åŸç‚¹æ˜¯ç›¸æœºçš„ç„¦ç‚¹ã€‚ç„¦ç‚¹ä¸€èˆ¬åœ¨ç›¸æœºå†…éƒ¨ï¼Œä¹Ÿå¯èƒ½è½åœ¨çš„ç›¸æœºå¤–éƒ¨ï¼Œè¿™å–å†³äºfocal lengthã€‚åæ ‡ç³»çš„æŒ‡å‘ï¼šxå’Œyå°±æ˜¯ç›¸å¹³é¢çš„æ¨ªçºµåæ ‡æ–¹å‘ï¼ˆç›¸æœºè§†è§’æ–¹å‘ï¼‰ï¼Œzæ˜¯ä¸xyå¹³é¢å‚ç›´çš„æ–¹å‘ï¼Œäº¦å³é•œå¤´æŒ‡å‘çš„å‰æ–¹ã€‚
  3. å›¾åƒåæ ‡ç³»ï¼ˆä¹Ÿå¯ä»¥åˆ†æˆä¸¤ä¸ªï¼šå›¾åƒåæ ‡ç³»(m)å’Œåƒç´ åæ ‡ç³»(pixel)ï¼‰ã€‚å€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯æ¯ä¸ªåƒç´ å¹¶ä¸æ˜¯çœŸæ­£çš„ä¸€ä¸ªç‚¹ï¼Œpixelåæ ‡ç³»æ‰€ä»£è¡¨çš„æ•´æ•°å€¼æ˜¯æ¯ä¸ªåƒç´ ç‚¹çš„ä¸­å¿ƒã€‚ 
- è€ƒè™‘åŠŸèƒ½æ€§ï¼Œè¿˜æœ‰ä¸€ä¸ªåŒè´¨åæ ‡ç³»ï¼Œç”¨äºå®é™…è¿ç®—ã€‚

<img src="ç›¸æœºæ ¡å‡†/image-20221021144051423.png" alt="image-20221021144051423" style="zoom: 25%;" />

## Intrinsic

- ç†æƒ³çŠ¶å†µä¸‹ï¼ˆæ— Skewnesså’ŒDistortionï¼‰ï¼ŒIntrinsic çŸ©é˜µEncodeçš„ä¿¡æ¯æœ‰ï¼šFocal Lengthã€Image Sensorçš„é•¿å®½ï¼ˆin pixelï¼‰ï¼Œæ¯åƒç´ ä»£è¡¨çš„ç±³æ•°(pixel/m)ï¼Œä¹Ÿå³ç›¸æœºçš„åˆ†è¾¨ç‡ã€‚

- éç†æƒ³æƒ…å†µä¸‹ï¼ŒSkewnesså’ŒDistortionä¹Ÿä¼šè¢«æ”¾åˆ°Intrinsicä¸­ã€‚

- å…³äºå½“æé«˜/é™ä½åˆ†è¾¨ç‡æ—¶å€™çš„Intrinsicå˜åŒ–ï¼š$k,l,c_x,c_y$éƒ½è¦ä¹˜ä»¥åˆ†è¾¨ç‡æé«˜çš„ç³»æ•°ã€‚

  ![image-20221026155238653](ç›¸æœºæ ¡å‡†/image-20221026155238653.png)

- å‚è§Intrinsicçš„è®¡ç®—è¿‡ç¨‹ï¼Œç”±äºè®¡ç®—æ—¶å·²ç»è€ƒè™‘äº†ç›®æ ‡ç‰©ä½“æ·±åº¦å¯¹æˆåƒä½ç½®çš„å½±å“ï¼Œæ‰€ä»¥Intrinsicå…¶å®æ˜¯åŒ…å«äº†é€è§†(perspective)ä¿¡æ¯çš„ã€‚

- Intrinsicå¯ä½¿ç›¸æœºåæ ‡ç³»è½¬åŒ–ä¸ºå›¾ç‰‡åæ ‡ç³»ã€‚

## Extrinsic

- Extrinsic å¯ä»¥çœ‹ä½œæ˜¯ä¸¤ä¸ªçŸ©é˜µå†™åœ¨äº†ä¸€èµ·ï¼šæ—‹è½¬çŸ©é˜µRå’Œå¹³ç§»çŸ©é˜µTã€‚å‰ä¸‰åˆ—æ˜¯Rï¼Œæœ€åä¸€åˆ—æ˜¯Tã€‚ å…¶å®ï¼Œè™½ç„¶ç»å¸¸å†™ä½œ$[R|T]$ï¼Œä½†äº‹å®ä¸Šè¿˜æœ‰ä¸€ä¸ªç›¸ä¼¼å˜æ¢Sï¼Œè¿™ä¸ªSæ˜¯ä¸ªå¯¹è§’çº¿çŸ©é˜µï¼Œå¯¹è§’çº¿ä¸Šçš„å€¼ä¸º$[S_x, S_y, S_z, 1]$ã€‚Sç›´æ¥å’ŒRä¹˜åœ¨ä¸€èµ·ï¼Œä¸Tæ— å…³ã€‚

  <img src="ç›¸æœºæ ¡å‡†/image-20221026162455644.png" alt="image-20221026162455644" style="zoom:50%;" />

- Extrinsicå¯ä½¿ä¸–ç•Œåæ ‡ç³»è½¬åŒ–ä¸ºç›¸æœºåæ ‡ç³»ã€‚

## Skewness and Distortion

- SkewnessæŒ‡çš„æ˜¯ç›¸æœºSensorçš„ä¸¤ä¸ªè½´ä¸å‚ç›´ï¼Œå³xyä¹‹é—´æœ‰ä¸€ä¸ªå°å¤¹è§’ã€‚é€šå¸¸è¿™ä¸ä¼šå‘ç”Ÿï¼Œä½†å¦‚æœæœ‰åˆ¶é€ æ–¹é¢çš„é—®é¢˜ï¼Œè¿™ä¹Ÿæ˜¯å¯èƒ½çš„ã€‚

- ç›¸æœºçš„Skewness

- Skewnessçš„è§£å†³æ–¹æ³•æ˜¯æŠŠè¿™ä¸ªå¤¹è§’æ‰¾åˆ°ï¼Œå¹¶åœ¨Intrinsicä¸­åæ˜ å‡ºæ¥ã€‚

  ![image-20221026154924465](ç›¸æœºæ ¡å‡†/image-20221026154924465.png)

- DistortionåŒ…å«ï¼š

  - *Radial Distortion* (å¾„å‘ç•¸å˜)ï¼š 
  - *Tangential distortion* (åˆ‡å‘ç•¸å˜)ï¼šæœ¬è´¨ä¸Šæ˜¯ç›¸å¹³é¢å’Œç›¸æœºåæ ‡ç³»å­˜åœ¨ä¸€ä¸ªå¤¹è§’ï¼Œå³â€œå›¾åƒSensorå’Œé•œå¤´æˆªé¢ä¸å¹³è¡Œâ€ã€‚

- å…³äºDistortionçš„è®¡ç®—ï¼š

  ![image-20221026163826434](ç›¸æœºæ ¡å‡†/image-20221026163826434.png)

## Homogeneous Coordinates

- åŒè´¨åæ ‡çš„ä¸»è¦ç”¨æ„æ˜¯æŠŠæœ¬æ¥åœ¨åˆ†æ¯ä¸Šçš„zï¼ˆæ·±åº¦ï¼‰ç»™æŒªèµ°ï¼Œä»¥ä¾¿è®©æŠ•å½±è¿™ä¸ªTransformationä»non-linearå˜æˆLinearã€‚
- æ³¨æ„åŒè´¨åæ ‡è™½ç„¶åœ¨è§†è§‰æ•ˆæœä¸Šæ˜¯åœ¨åŸæœ¬çš„åæ ‡(u,v)æˆ–(x,y,z)ä¸‹é¢åŠ äº†ä¸€ä¸ª1ï¼Œä½†æ˜¯å®é™…ä¸Šè¿™ä¸ª1åœ¨æ¬§å¼åæ ‡ç³»ä¸­å¹¶ä¸å­˜åœ¨ã€‚å½“æˆ‘ä»¬åé¢åˆ—å‡ºæ–¹ç¨‹æ ¡å‡†æ—¶ï¼Œåº”è¯¥å›åˆ°åŸæœ¬çš„æ¬§å¼åæ ‡ç³»è§£ã€‚



## IMU

- IMUè¾“å‡ºä¸‰ä¸ªæ–¹å‘è§’é€Ÿåº¦å’Œä¸‰ä¸ªè½´å‘åŠ é€Ÿåº¦çš„å€¼ï¼Œä½¿ç”¨æ—¶ä¹Ÿéœ€è¦æ ¡å‡†ã€‚
- å…·ä½“æ ¡å‡†æ–¹æ³•å‚è§Kalibrå’ŒDVï¼Œå› ä¸ºæˆ‘æ²¡ç”¨ä¸Šï¼Œæ‰€ä»¥ä¸å¤šå±•å¼€ã€‚

## DVS

- DVSçš„æ ¡å‡†ä¸»è¦åˆ†ä¸ºä¸¤ç§æ–¹æ³•ï¼š
  - ä¸€ç§æ˜¯ç›´æ¥ç”¨pairedçš„RGBè¿›è¡Œæ ¡å‡†ï¼Œæ¯•ç«Ÿè¿™é‡Œçš„RGBå’ŒDVS shareåŒä¸€ç»„é€é•œã€‚
  - å¦‚æœæ²¡æœ‰è¿™ä¸ªRGBï¼Œå°±ç›´æ¥ç”¨accumulateçš„frameåšæ ¡å‡†ã€‚

## Methods

### è§£æ–¹ç¨‹ç›´æ¥æ ¡å‡†PçŸ©é˜µ

- åœ¨Paper *DHP19: Dynamic Vision Sensor 3D Human Pose Dataset*é‡Œï¼Œ ä»–ä»¬é‡‡ç”¨çš„æ–¹æ³•æ˜¯ï¼šç›´æ¥åœ¨ç»è¿‡Mocapæ ¡å‡†çš„ç©ºé—´ä¸­æ”¾ç½®ä¸€ç³»åˆ—Markersï¼Œç„¶ååœ¨DVSçš„RGBï¼ˆAPSï¼‰è¾“å‡ºframeä¸­ç›´æ¥è¿›è¡Œæ‰‹åŠ¨æ ‡æ³¨ï¼Œå¾—åˆ°å…¶åœ¨image planeä¸­çš„$(u, v)$åæ ‡ï¼Œ ç„¶åè§£æ–¹ç¨‹ã€‚

  <img src="ç›¸æœºæ ¡å‡†/image-20221021155115039.png" alt="image-20221021155115039" style="zoom:40%;" />

- ä¸Šå›¾ä¸­æåˆ°äº†ä¸€ä¸ªç‚¹ï¼šä»æŠ•å½±çŸ©é˜µè®¡ç®—ç›¸æœºåæ ‡ç³»çš„åŸç‚¹ï¼Œå³ç›¸æœºçš„ç„¦ç‚¹ä½ç½®çš„æ–¹æ³•ï¼š$C=Q^{-1}c_4$ã€‚å…·ä½“çš„æ¨ç†å…¶å®å¾ˆç®€å•ï¼Œä¸»è¦å°±é ä¸€ä¸ªæ¡ä»¶å…¬å¼ï¼š$PC=0$ï¼Œå³åŸç‚¹çš„æŠ•å½±æ˜¯0ã€‚

- ç»†èŠ‚ä¸Šï¼Œä»–ä»¬ç”¨äº†38ä¸ªMarkerï¼Œå¹¶8æ¬¡æ”¹å˜å®ƒä»¬çš„ä½ç½®ï¼Œé€šè¿‡æœ€å°å¹³æ–¹æ³•è§£å¾—æœ€æ¥è¿‘çš„11ä¸ªPä¸­å‚æ•°å€¼ã€‚è¿™é‡Œçš„æœ€å°å¹³æ–¹æ³•çš„æ„ä¹‰åœ¨äºé€šè¿‡å¢åŠ æ•°æ®ç‚¹å–å¹³å‡På€¼æ¥å‡å°è¯¯å·®ã€‚å…¶å®11ç»„å¼å­å°±å¤Ÿäº†ï¼Œä½†è¿™é‡Œè¿˜æ˜¯ç”¨äº†$8\times38\times2$ä¸ªå…¬å¼ï¼Œå°±åœ¨äºæ­¤ã€‚

- å…·ä½“çš„æœ€å°å¹³æ–¹æ³•ä»‹ç»åŠä»£ç ï¼š[Link](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter16.04-Least-Squares-Regression-in-Python.html)

- è¿™ä¸ªå…¨çŸ©é˜µPå…¶å®åŒ…å«äº†Camera Intrinsic *K*ï¼Œ Camera Extrinsic *RT*, ä»¥åŠCamera Skewnessã€‚

- ç†è®ºï¼š

  ![image-20221026175034098](ç›¸æœºæ ¡å‡†/image-20221026175034098.png)

  <img src="ç›¸æœºæ ¡å‡†/image-20221026175051047.png" alt="image-20221026175051047" style="zoom:50%;" />

- ä»£ç ï¼š

  ```python
  # Least Square Calibration for Camera Projection Matrix using Numpy
  def svd_calibration(points_3d, points_2d):
      # points_3d: 3D points in world coordinate
      # points_2d: 2D points in image coordinate
      # return: projection matrix
      assert points_3d.shape[0] == points_2d.shape[0]
      assert points_3d.shape[1] == 3
      assert points_2d.shape[1] == 2
      num_points = points_3d.shape[0]
      A = np.zeros((2 * num_points, 12))
      for i in range(num_points):
          A[2 * i, 0:4] = *(points_3d[i, :]), 1
          A[2 * i, 8:12] = *(-points_2d[i, 0] * points_3d[i, :]), -points_2d[i, 0]
          A[2 * i + 1, 4:8] = *(points_3d[i, :]), 1
          A[2 * i + 1, 8:12] = *(-points_2d[i, 1] * points_3d[i, :]), -points_2d[i, 0]
      U, S, V = np.linalg.svd(A)
      P = V[-1, :].reshape((3, 4))
      return P
  
  # OR
    
  # Least Square Calibration for Camera Projection Matrix
  def least_square_calibrate_camera_projection_matrix_np(x,y,z,u,v):
      # x,y,z: 3D points in world coordinate
      # u,v: 2D points in image coordinate
      # return: projection matrix
      assert len(x) == len(y) == len(z) == len(u) == len(v)
      num_points = len(x)
      A = np.zeros((2 * num_points, 12))
      for i in range(num_points):
          A[2 * i, 0:4] = x[i], y[i], z[i], 1
          A[2 * i, 8:12] = -u[i] * x[i], -u[i] * y[i], -u[i] * z[i], -u[i]
          A[2 * i + 1, 4:8] = x[i], y[i], z[i], 1
          A[2 * i + 1, 8:12] = -v[i] * x[i], -v[i] * y[i], -v[i] * z[i], -v[i]
      U, S, V = np.linalg.svd(A)
      P = V[-1, :].reshape((3, 4))
      return P
  ```

- æ³¨æ„ï¼šSVDè¿™é‡Œæ˜¯ç”¨äºè§£å†³Least Squares Problemçš„ï¼Œå¦‚æœç›´æ¥ç”¨`np.linalg.lstsq`å‡½æ•°çš„è¯ï¼ˆbå–å…¨0ï¼‰ï¼Œä¼šè§£å¾—ä¸€ä¸ªå…¨0çŸ©é˜µï¼ˆå› ä¸º0æ°¸è¿œæ˜¯ä¸€ä¸ªè§£ï¼‰ã€‚

- SVDçš„è§£æ³•ç»†èŠ‚ï¼š

  ![image-20221027230723755](ç›¸æœºæ ¡å‡†/image-20221027230723755.png)

- è§£SVDçš„æ—¶å€™å¯ä»¥é€‰æ‹©æŠŠPçŸ©é˜µå³ä¸‹è§’$P_{(3,4)}$è®¾ä¸º1ã€‚ä¸è®¾æ˜¯homogeneousè§£æ³•ï¼Œè®¾äº†ä¹‹åæ˜¯inhomogeneousã€‚

### kalibr

- [Link](https://github.com/ethz-asl/kalibr)

- Used for:

  1. **Multi-Camera Calibration**: Intrinsic and extrinsic calibration of a camera-systems with non-globally shared overlapping fields of view
  2. **Visual-Inertial Calibration (CAM-IMU)**: Spatial and temporal calibration of an IMU w.r.t a camera-system along with IMU intrinsic parameters
  3. **Multi-Inertial Calibration (IMU-IMU)**: Spatial and temporal calibration of an IMU w.r.t a base inertial sensor along with IMU intrinsic parameters (requires 1-aiding camera sensor).
  4. **Rolling Shutter Camera Calibration**: Full intrinsic calibration (projection, distortion and shutter parameters) of rolling shutter cameras.

- ç®€å•è¯´å°±æ˜¯ä¸»æ”»å¤šç›¸æœº/IMUç³»ç»Ÿã€‚[å¤šä¸ªç›¸æœº](https://github.com/ethz-asl/kalibr/wiki/multiple-camera-calibration)ï¼Œ[å¤šä¸ªIMU](https://github.com/ethz-asl/kalibr/wiki/Multi-IMU-and-IMU-intrinsic-calibration)ï¼Œ[ç›¸æœº+IMU](https://github.com/ethz-asl/kalibr/wiki/camera-imu-calibration)ç­‰ã€‚

- æ ¡å‡†å‡ºæ¥çš„Extrinsicç»“æœå¹¶ä¸æ˜¯ç›¸å¯¹åŸç‚¹ç»å¯¹çš„ï¼Œè€Œæ˜¯å¤šä¸ªè®¾å¤‡é—´ç›¸å¯¹çš„ã€‚æ¯”å¦‚IMU+Camæ ¡å‡†å‡ºæ¥çš„Extrinsicå°±æ˜¯IMUç›¸å¯¹äºCamåæ ‡çš„å˜æ¢ã€‚

  å¼•ç”¨ä¸€æ®µ[åŸè¯](https://github.com/ethz-asl/kalibr/wiki/yaml-formats)ï¼š

  > - **T_cn_cnm1**
  >   camera extrinsic transformation, always with respect to the last camera in the chain
  >   (e.g. cam1: T_cn_cnm1 = T_c1_c0, takes cam0 to cam1 coordinates)
  > - **T_cam_imu**
  >   IMU extrinsics: transformation from IMU to camera coordinates (T_c_i)
  > - **timeshift_cam_imu**
  >   timeshift between camera and IMU timestamps in seconds (t_imu = t_cam + shift)

- ç»¼ä¸Šæ‰€è¿°ï¼ŒKalibrå¹¶ä¸æ˜¯æ»¡è¶³æˆ‘ä»¬éœ€æ±‚çš„æ ¡å‡†æ–¹æ¡ˆã€‚

### DV Calibration

- [Tutorial Link](https://inivation.gitlab.io/dv/dv-docs/docs/tutorial-calibration/), [Code Link](https://gitlab.com/inivation/dv/dv-imu-cam-calibration)
- å•ä¸ªå¤šä¸ªDVSéƒ½å¯ä»¥ã€‚
- åŸºäºKalibrçš„æ–¹æ¡ˆã€‚
- å¯¹äºå•ä¸ªDVSï¼Œæ ¡å‡†ä¸»è¦è¿›è¡Œçš„æ˜¯undistortionï¼Œä¸”å¯ä»¥åœ¨æ ¡å‡†åç›´æ¥åº”ç”¨äºç›¸æœºåç»­çš„å›¾åƒï¼Œè®©åé¢çš„recordéƒ½ä¸å†æœ‰å¤±çœŸã€‚
- è¿™é‡Œçš„æ ¡å‡†å¯ä»¥æœ‰æ•ˆåº”å¯¹ä¹‹å‰Upalæ•™æˆæå‡ºçš„æ‰­æ›²é—®é¢˜ï¼Œåº”åœ¨åç»­æ“ä½œä¸­åº”ç”¨ã€‚

### OpenCV Camera Calibration

- è¿™ä¸ªæ ¡å‡†ä¼šä½¿ç”¨chessboardï¼Œè€Œå…³äº3dåæ ‡ï¼Œä»–ä»¬ç”¨äº†æ£‹ç›˜ä¸Šä¸¤ä¸ªç›¸é‚»çš„ç‚¹çš„å®é™…è·ç¦»æ˜¯å·²çŸ¥çš„è¿™ä¸ªç‰¹æ€§ï¼ˆå› ä¸ºæ‰“å°çš„æ ‡å‡†æ£‹ç›˜ï¼Œé—´è·æ˜¯å›ºå®šçš„ï¼Œå¦‚30mmï¼‰ï¼Œæ¥æä¾›ç›¸åº”çš„3Dåæ ‡ä¿¡æ¯ã€‚

- è¿™ä¸ªæ ¡å‡†ä¼šåˆ†åˆ«è¾“å‡ºIntrinsic matrix (mtx), rotation matrix (R, rvecs), translation matrix (T, tvecs), Distortion coefficients (dist)ã€‚è¿™äº›è¾“å‡ºå¯ä»¥ç›´æ¥è¢«ç”¨æ¥çº åã€‚

  ```python
  # generate camera matrixes
  ret, mtx, dist, rvecs, tvecs = cv.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
  
  img = cv.imread('left12.jpg')
  h,  w = img.shape[:2]
  newcameramtx, roi = cv.getOptimalNewCameraMatrix(mtx, dist, (w,h), 1, (w,h))
  
  # undistort
  dst = cv.undistort(img, mtx, dist, None, newcameramtx)
  # crop the image
  x, y, w, h = roi
  dst = dst[y:y+h, x:x+w]
  cv.imwrite('calibresult.png', dst)
  ```

- å…³äºOpenCVæ ¡å‡†å‡ºæ¥çš„Extrinsic Matrixï¼Œç”±äºä¸–ç•Œåæ ‡ç³»å¿…å®šæœ‰ä¸€ä¸ªåŸç‚¹ï¼Œæ‰€ä»¥å®ƒä»¬ä¹Ÿæ˜¯æ¯«æ— ç–‘é—®æœ‰ä¸€ä¸ªåŸç‚¹çš„ã€‚ä½†è¿™ä¸ªä¸–ç•Œåæ ‡ç³»åŸç‚¹å®é™…ä¸Šåªæœ‰å‚è€ƒæ„ä¹‰ï¼ˆç¬¬ä¸€å¼ æ ¡å‡†å›¾çš„å·¦ä¸Šè§’æ£‹ç›˜ç‚¹ï¼‰ï¼Œå¹¶æ— æ³•ç›´æ¥ä½¿ç”¨ã€‚åŒæ—¶ï¼Œç›¸æœºåæ ‡ç³»çš„åŸç‚¹æ˜¯ç›¸æœºçš„ç„¦ç‚¹ï¼Œè€Œè¿™ä¸ªç„¦ç‚¹ä¹Ÿæ˜¯å‡ ä¹ä¸å¯é¢„çŸ¥å’Œæµ‹é‡ä½ç½®çš„ï¼ˆå®ƒå¯èƒ½åœ¨ç›¸æœºå†…éƒ¨æˆ–å¤–éƒ¨ï¼Œä½†æ ¡å‡†å¹¶ä¸ä¼šå‘Šè¯‰ä½ è¿™ä¸ªç‚¹ä½ç½®ï¼Œæ‰€ä»¥ä½ ä¹Ÿæ— æ³•é€šè¿‡ç›´æ¥æµ‹é‡ç›¸æœºOç‚¹å’Œå®é™…ä¸–ç•ŒOç‚¹ä¹‹é—´çš„ç›¸å¯¹ä½ç½®æ¥çº æ­£Extrinsicã€‚ï¼‰

  > [Link](https://www.appsloveworld.com/opencv/100/91/opencv-camera-calibration-world-coordinate-system-origin): I believe it used to be the position of the top-left corner of the checkerboard in the first calibration image, but it may have changed. You can visualized it by writing a few lines of code that project point (0,0,0) (in calibrated scene coordinates) in all the calibration images, then plotting its projected image coordinates on top of the image themselves.
  >
  > You should really not depend on it being anything meaningful, and instead locate a separate feature in 3D and roto-translate the reference frame to it after calibration.

- å®é™…ä¸Šï¼Œä¸è¦æƒ³é€šè¿‡OpenCVçš„æ ¡å‡†æ¥ç›´æ¥å¾—åˆ°æœ‰å®é™…æ„ä¹‰çš„Extrinsicï¼Œè‹¥æƒ³å¾—åˆ°ï¼Œè¯·è‡ªè¡Œç”¨å‰é¢æåˆ°çš„Method 1æ¥å®é™…labelä¸€äº›å·²çŸ¥3Dåæ ‡çš„Markerså¯¹åº”çš„2Dç‚¹ï¼Œç”¨Least Squaresè§£å¾—ã€‚

- ä½†æ˜¯ï¼ŒOpenCVçš„æ ¡å‡†å¯ä»¥æä¾›æœ‰æ•ˆçš„Distortion Coefficientå’ŒIntrinsicï¼Œå¹¶å¯ç›´æ¥è¢«ç”¨äºç•¸å˜è¡¥å¿ã€‚

## Reference

### Blogs/Websites

- [Least Squares Regression in Python](****https://pythonnumericalmethods.berkeley.edu/notebooks/chapter16.04-Least-Squares-Regression-in-Python.html****)
- [Why does SVD provide the least squares and least norm solution to ğ´ğ‘¥=ğ‘?](https://math.stackexchange.com/questions/974193/why-does-svd-provide-the-least-squares-and-least-norm-solution-to-a-x-b)
- [How does the SVD solve the least squares problem?](https://math.stackexchange.com/questions/772039/how-does-the-svd-solve-the-least-squares-problem)
- [What is the "real world coordinate system" camera calibration refer to in computer vision?](https://www.quora.com/What-is-the-real-world-coordinate-system-camera-calibration-refer-to-in-computer-vision)
- [numpy linalg svd](https://numpy.org/doc/stable/reference/generated/numpy.linalg.svd.html)
- [OpenCV Camera Calibration](https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html)

### Slides

- [Udacity CS4495/6495 Introduction to Computer Vision 3C-L3 Calibrating cameras](https://s3.amazonaws.com/content.udacity-data.com/courses/ud810/slides/Unit-3/3C-L3.pdf#fromHistory)
- [CMU - Camera Matrix](https://www.cs.cmu.edu/~16385/s17/Slides/11.1_Camera_matrix.pdf)
- [Stanford - Lecture 2](https://cvgl.stanford.edu/teaching/cs231a_winter1314/lectures/lecture2_camera_models.pdf)
- [Stanford - Lecture 3](https://cvgl.stanford.edu/teaching/cs231a_winter1314/lectures/lecture3_camera_calibration.pdf)

### Papers

- [A Flexible New Technique for Camera Calibration](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr98-71.pdf)

